<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Matter.js — Natural Coil Hose + Realistic Nozzle + Water (frozen gravity per droplet)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body { margin:0; height:100%; background:#f5efe6; }
    #scene { display:block; width:100vw; height:100vh; }
  </style>
  <!-- Primary CDN -->
  <script src="https://unpkg.com/matter-js@0.19.0/build/matter.min.js"></script>
  <!-- Fallback CDN -->
  <script>if(!window.Matter){document.write('<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"><\\/script>')}</script>
</head>
<body>
<canvas id="scene"></canvas>
<script>
(() => {
  if (!window.Matter) { alert('Could not load Matter.js'); return; }

  const { Engine, Render, Runner, World, Bodies, Body, Composite, Events } = Matter;

  const W = Math.max(900, innerWidth);
  const H = Math.max(600, innerHeight);

  /* ---------- Engine / Renderer ---------- */
  const engine = Engine.create();
  engine.world.gravity.y = 1; // mouse will change this live; hose stays static
  const render = Render.create({
    canvas: document.getElementById('scene'),
    engine,
    options: { width: W, height: H, wireframes:false, background:'#f5efe6', pixelRatio: devicePixelRatio }
  });
  Render.run(render);
  Runner.run(Runner.create(), engine);

  /* ---------- Bounds + a wall to hit ---------- */
  World.add(engine.world, [
    Bodies.rectangle(W/2, H+40, W, 80, { isStatic:true, render:{ fillStyle:'#e6ded0' } }),
    Bodies.rectangle(-40, H/2, 80, H, { isStatic:true, render:{ visible:false } }),
    Bodies.rectangle(W+40, H/2, 80, H, { isStatic:true, render:{ visible:false } }),
    Bodies.rectangle(W/2, -40, W, 80,   { isStatic:true, render:{ visible:false } }),
    Bodies.rectangle(Math.min(W-80, W*0.87), H*0.55, 20, Math.min(520, H*0.7),
      { isStatic:true, render:{ fillStyle:'#60a9ff' } })
  ]);

  /* ---------- Vec helpers ---------- */
  const V = {
    add:(a,b)=>({x:a.x+b.x,y:a.y+b.y}),
    sub:(a,b)=>({x:a.x-b.x,y:a.y-b.y}),
    mul:(a,s)=>({x:a.x*s,y:a.y*s}),
    len:(a)=>Math.hypot(a.x,a.y),
    n:(a)=>{const L=Math.hypot(a.x,a.y)||1e-9; return {x:a.x/L,y:a.y/L}},
    rot:(a,t)=>({x:a.x*Math.cos(t)-a.y*Math.sin(t), y:a.x*Math.sin(t)+a.y*Math.cos(t)}),
  };

  /* ---------- Lay a thick static hose along a path ---------- */
  function addHosePath(points, thickness, style){
    const comp = Composite.create({ label:'hose' });
    const overlap = thickness*0.9;
    for (let i=1;i<points.length;i++){
      const p0 = points[i-1], p1 = points[i];
      const mid = { x:(p0.x+p1.x)/2, y:(p0.y+p1.y)/2 };
      const d   = V.len(V.sub(p1,p0));
      const ang = Math.atan2(p1.y-p0.y, p1.x-p0.x);
      const seg = Bodies.rectangle(mid.x, mid.y, d+overlap, thickness, {
        isStatic:true,
        chamfer:{ radius: thickness*0.5 },
        render:{ fillStyle: style.fill, strokeStyle: style.stroke, lineWidth: style.lineWidth }
      });
      Body.setAngle(seg, ang);
      Composite.add(comp, seg);
    }
    World.add(engine.world, comp);
  }

  /* ---------- Build coil that looks hand-wrapped + kinked tail ---------- */
  function buildCoilAndNozzle() {
    const thickness = 30;
    const center   = { x: W*0.33, y: H*0.67 };
    const turns    = 3.5;
    const spacing  = 54;
    const baseR    = 70;
    const step     = 0.18;

    const xScale = 1.22, yScale = 0.92;  // flattened ellipse like the reference
    const noiseAmp = 11, noiseFreq = 0.85;
    const drift = 18;

    const pts = [];
    const a = baseR, b = spacing/(2*Math.PI);
    for (let t=0; t<=turns*2*Math.PI; t+=step) {
      const r = a + b*t + noiseAmp*Math.sin(t*noiseFreq) + (t/(turns*2*Math.PI))*drift;
      pts.push({ x: center.x + xScale*r*Math.cos(t),
                 y: center.y + yScale*r*Math.sin(t) });
    }

    // Tail with a visible kink before the nozzle
    const last = pts[pts.length-1], prev = pts[pts.length-2];
    let dir  = V.n(V.sub(last, prev));
    const n  = { x:-dir.y, y:dir.x };
    const start = V.add(last, V.add(V.mul(n, thickness*0.85), V.mul(dir, thickness*0.55)));

    // first leg (turn slightly)
    let kinkDir = V.rot(dir, -0.38);          // ~ -22°
    for (let d=12; d<=80; d+=12) pts.push( V.add(start, V.mul(kinkDir, d)) );

    // second leg (less turn)
    const join = pts[pts.length-1];
    kinkDir = V.rot(dir, -0.12);
    for (let d=12; d<=130; d+=12) pts.push( V.add(join, V.mul(kinkDir, d)) );

    // Hose body
    addHosePath(pts, thickness, { fill:'#715a3a', stroke:'#59472c', lineWidth:2 });

    // Nozzle pieces aligned to tail tangent
    const tipTail = pts[pts.length-1], tipPrev = pts[pts.length-2];
    const tdir = V.n(V.sub(tipTail, tipPrev));
    const ang  = Math.atan2(tdir.y, tdir.x);

    const nozzleLen   = thickness*1.9;
    const nozzleWidth = thickness*1.12;
    const gap         = Math.max(thickness*0.55, nozzleWidth*0.55);

    const coupler = Bodies.circle(
      tipTail.x + tdir.x*(gap*0.55),
      tipTail.y + tdir.y*(gap*0.55),
      nozzleWidth*0.46,
      { isStatic:true, render:{ fillStyle:'#b9c0c7', strokeStyle:'#6b737a', lineWidth:2 } }
    );

    const barrel = Bodies.rectangle(
      tipTail.x + tdir.x*(gap + nozzleLen*0.42),
      tipTail.y + tdir.y*(gap + nozzleLen*0.42),
      nozzleLen*0.8, nozzleWidth*0.70,
      { isStatic:true, chamfer:{ radius: nozzleWidth*0.28 },
        render:{ fillStyle:'#c7ced5', strokeStyle:'#6a7280', lineWidth:2 } }
    ); Body.setAngle(barrel, ang);

    const neck = Bodies.rectangle(
      tipTail.x + tdir.x*(gap + nozzleLen*0.82),
      tipTail.y + tdir.y*(gap + nozzleLen*0.82),
      nozzleLen*0.45, nozzleWidth*0.48,
      { isStatic:true, chamfer:{ radius: nozzleWidth*0.20 },
        render:{ fillStyle:'#d7dee5', strokeStyle:'#656c74', lineWidth:2 } }
    ); Body.setAngle(neck, ang);

    const tipRing = Bodies.circle(
      tipTail.x + tdir.x*(gap + nozzleLen*1.05),
      tipTail.y + tdir.y*(gap + nozzleLen*1.05),
      nozzleWidth*0.26,
      { isStatic:true, render:{ fillStyle:'#e7eef4', strokeStyle:'#606770', lineWidth:2 } }
    );

    World.add(engine.world, [coupler, barrel, neck, tipRing]);

    // Emitter mouth in front of tip ring
    const mouth = {
      x: tipRing.position.x + tdir.x*(nozzleLen*0.18 + 6),
      y: tipRing.position.y + tdir.y*(nozzleLen*0.18 + 6)
    };
    return { mouth, dir: tdir };
  }

  const hose = buildCoilAndNozzle();

  /* ---------- Water config (with per-droplet frozen gravity) ---------- */
  const WATER = {
    radius: 2.2,
    jetWidth: 20,
    dropsPerTick: 16,
    speedPerTick: 13,
    collideWithSelf: false,
    maxCount: 1800,
    angleJitterDeg: 7,
    speedJitter: 0.12,
    sizeJitter: 0.22,
    turbulence: 0.00003
  };

  // negative group => no self-collide, positive => always collide
  const WATER_GROUP = Body.nextGroup(!WATER.collideWithSelf);

  function emitOne(origin, baseDir){
    // spread across aperture (perpendicular)
    const n = { x:-baseDir.y, y:baseDir.x };
    const nn = V.n(n);
    const off = (Math.random()*2 - 1) * (WATER.jetWidth*0.5);

    // jitter angle/speed/size
    const ang = (WATER.angleJitterDeg * Math.PI/180) * (Math.random()*2 - 1);
    const dir = V.n( V.rot(baseDir, ang) );
    const radius = Math.max(0.6, WATER.radius * (1 + (Math.random()*2-1)*WATER.sizeJitter));
    const speed  = Math.max(6, WATER.speedPerTick * (1 + (Math.random()*2-1)*WATER.speedJitter));

    const spawn = { x: origin.x + nn.x*off, y: origin.y + nn.y*off };
    const d = Bodies.circle(spawn.x, spawn.y, radius, {
      label:'water',
      friction:0, frictionStatic:0, frictionAir:0.01, restitution:0.02, density:0.0009,
      collisionFilter:{ group: WATER_GROUP },
      render:{ fillStyle:'#3aa6ff', lineWidth:0 }
    });
    Body.setVelocity(d, V.mul(dir, speed));

    // >>> FREEZE GRAVITY AT SPAWN <<<
    d._g = { x: engine.world.gravity.x, y: engine.world.gravity.y };

    d._phase = Math.random()*Math.PI*2; // for turbulence wobble
    World.add(engine.world, d);
  }

  // Compensate world gravity changes so each droplet keeps its spawn gravity.
  Events.on(engine, 'beforeUpdate', () => {
    const gw = engine.world.gravity;
    const scale = gw.scale || 0.001; // default gravity scale
    const bodies = Composite.allBodies(engine.world);
    for (const b of bodies) {
      if (b.label !== 'water' || !b._g) continue;
      const fx = (b._g.x - gw.x) * b.mass * scale;
      const fy = (b._g.y - gw.y) * b.mass * scale;
      Body.applyForce(b, b.position, { x: fx, y: fy });
    }
  });

  function cleanup(){
    const bodies = Composite.allBodies(engine.world);
    const water = bodies.filter(b => b.label==='water');
    if (water.length > WATER.maxCount) {
      for (let i=0; i<water.length - WATER.maxCount; i++) World.remove(engine.world, water[i]);
    }
    for (const b of water) {
      const p = b.position;
      if (p.x < -200 || p.x > W+200 || p.y < -200 || p.y > H+200) World.remove(engine.world, b);
    }
  }

  Events.on(engine, 'afterUpdate', () => {
    for (let i=0; i<WATER.dropsPerTick; i++) emitOne(hose.mouth, hose.dir);

    // tiny turbulence to avoid straight-line alignment
    if (WATER.turbulence > 0) {
      const t = engine.timing.timestamp/1000;
      const bodies = Composite.allBodies(engine.world);
      for (const b of bodies) {
        if (b.label!=='water') continue;
        const mag = WATER.turbulence * b.mass;
        const f = { x: -b.velocity.y * mag * Math.sin(t*6 + b._phase),
                    y:  b.velocity.x * mag * Math.cos(t*4.7 + b._phase*0.7) };
        Body.applyForce(b, b.position, f);
      }
    }
    cleanup();
  });

  /* ---------- Mouse tilts gravity (existing drops keep their own) ---------- */
  addEventListener('mousemove', e => {
    engine.world.gravity.x = (e.clientX/W - 0.5) * 2;
    engine.world.gravity.y = (e.clientY/H - 0.5) * 2;
  });
})();
</script>
</body>
</html>

